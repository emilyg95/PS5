checkValidityTrap(Trap2)
checkValidityTrap = function(object){
if (checkLength != TRUE | checkSpacing!= TRUE){
return("object is not a valid value")}
else{
return(TRUE)}
}
checkValidityTrap = function(object){
if (checkLength != TRUE | checkSpacing!= TRUE){
return("object is not a valid value")}
else{
return(TRUE)}
}
setValidity("Trapezoid", checkValidityTrap)
Trap1 = newTrapezoid(q,z)
checkValidityTrap = function(object){
checkLength(object)
checkSpacing(object)
if (checkLength != TRUE | checkSpacing!= TRUE){
return("object is not a valid value")}
else{
return(TRUE)}
}
setValidity("Trapezoid", checkValidityTrap)
Trap1 = newTrapezoid(q,z)
Trap2 = newTrapezoid(z,w)
checkValidityTrap(Trap1)
checkValidityTrap = function(object){
if (checkLength(object) != TRUE | checkSpacing(object) != TRUE){
return("object is not a valid value")}
else{
return(TRUE)}
}
checkValidityTrap(Trap1)
checkValidityTrap(Trap2)
setValidity("Trapezoid", checkValidityTrap)
validObject(Trap1)
ValidObject(Trap2)
validObject(Trap1)
validObject(Trap2)
Trap1 = newTrapezoid(q,z)
Trap2 = newTrapezoid(z,w)
Trap3 = newTrapezoid(p,w)
Trap3 = newTrapezoid(p,q)
checkValiditySimpson = function(object){ ## feeds checkLength, checkSpacing, and checkIntervals into validity function for simpson
if (checkLength(object) != TRUE | checkSpacing(object) != TRUE | checkIntervals(object) != TRUE){ ## returns an error message if either test does not pass
return("object is not a valid value")}
else{
return(TRUE)}
}
checkValiditySimpson(Simpson1)
checkValiditySimpson(Trap1)
checkValiditySimpson(Simpson2) ## test
Simpson4 = newSimpson(1:4, 1:4)
Simpson4 = newSimpson(1:4, 4:8)
Simpson4 = newSimpson(1:4, 5:8)
checkValiditySimpson(Simpson4) ## test
Trap4 = newTrapezoid(1:4, 5:8)
setValidity("Simpson", checkValiditySimpson)
Simpson1 = newSimpson(1:4, 1:4)
Simpson2 = newSimpson(1:5, 5:10)
Simpson2 = newSimpson(1:5, 5:9)
setMethod("integrateIt",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
setMethod("integrateIt", "numeric",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
setMethod("integrateIt", "Trapezoid",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
setMethod("integrateIt", "Trapezoid",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
generic = function(x = "numeric", y = "numeric", rule = "character"){ ## creates the interior function for set generic which takes as an input x, y, and rule
standardGeneric("integrateIt")
}
setGeneric("integrateIt", generic) ## sets the generic function of integrateIt as generic
setMethod("integrateIt", "Trapezoid",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
setMethod("integrateIt",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
setClass(Class = "Integral",
slots = list(x = "numeric",
y = "numeric",
rule = "character")) ## indicates 3 inputs; x and y, which must both be numeric, and rule, which must be a character
generic = function(object = "Integral"){ ## creates the interior function for set generic which takes as an input x, y, and rule
standardGeneric("integrateIt")
}
setGeneric("integrateIt", generic) ## sets the generic function of integrateIt as generic
setMethod("integrateIt", "Integral",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
integrateIt(1:4, 1:4, Trap)
setClass(Class = "Integral",
representation = representation(
x = "numeric",
y = "numeric",
rule = "character")) ## indicates 3 inputs; x and y, which must both be numeric, and rule, which must be a character
setGeneric("integrateIt", generic) ## sets the generic function of integrateIt as generic
generic = function(object = "Integral"){ ## creates the interior function for set generic which takes as an input x, y, and rule
standardGeneric("integrateIt")
}
setGeneric("integrateIt", generic) ## sets the generic function of integrateIt as generic
setMethod("integrateIt", "Integral",
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
integrateIt(1:4, 1:4, Trap)
setMethod("integrateIt", signature("Integral"),
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
integrateIt(1:4, 1:4, Trap)
setClass(Class = "Integral",
representation = representation(
x = "numeric",
y = "numeric",
rule = "character")) ## indicates 3 inputs; x and y, which must both be numeric, and rule, which must be a character
newIntegral = function(x, y, rule){ ## construction function takes in 2 arguments; x and y
object = new("Integral", x = x, y = y, rule = z) ## creates a new object setting the 2 inputs x and y as defined for class Trapezoid
return(object) ## returns the object
}
setMethod("integrateIt", signature("Integral"),
function(object){
if(object@rule == "Trap"){
return(c(newTrapezoid(object), Trap(object), "Trapezoid"))
}
else{
return(c(newSimpson(object), Simpson(object), "Simpson"))
}
}
)
integrateIt(1:4, 1:4, Trap)
integrateIt(newIntegral(1:4, 1:4, Trap))
integrateIt(newIntegral(1:4, 1:4, Trap))
function (object, test = FALSE, complete = FALSE)
{
Class <- class(object)
classDef <- getClassDef(Class)
where <- .classEnv(classDef)
anyStrings <- function(x) if (identical(x, TRUE))
character()
else x
errors <- character()
slotTypes <- classDef@slots
slotNames <- names(slotTypes)
attrNames <- c(".Data", ".S3Class", names(attributes(object)))
if (any(is.na(match(slotNames, attrNames)))) {
badSlots <- is.na(match(slotNames, attrNames))
errors <- c(errors, paste("slots in class definition but not in object:",
paste0("\"", slotNames[badSlots], "\"", collapse = ", ")))
slotTypes <- slotTypes[!badSlots]
slotNames <- slotNames[!badSlots]
}
for (i in seq_along(slotTypes)) {
classi <- slotTypes[[i]]
classDefi <- getClassDef(classi, where = where)
if (is.null(classDefi)) {
errors <- c(errors, paste0("undefined class for slot \"",
slotNames[[i]], "\" (\"", classi, "\")"))
next
}
namei <- slotNames[[i]]
sloti <- try(switch(namei, .S3Class = S3Class(object),
slot(object, namei)), silent = TRUE)
if (inherits(sloti, "try-error")) {
errors <- c(errors, sloti)
next
}
ok <- possibleExtends(class(sloti), classi, ClassDef2 = classDefi)
if (identical(ok, FALSE)) {
errors <- c(errors, paste0("invalid object for slot \"",
slotNames[[i]], "\" in class \"", Class, "\": got class \"",
class(sloti), "\", should be or extend class \"",
classi, "\""))
next
}
if (!complete)
next
errori <- anyStrings(Recall(sloti, TRUE, TRUE))
if (length(errori)) {
errori <- paste0("In slot \"", slotNames[[i]], "\" of class \"",
class(sloti), "\": ", errori)
errors <- c(errors, errori)
}
}
extends <- rev(classDef@contains)
for (i in seq_along(extends)) {
exti <- extends[[i]]
superClass <- exti@superClass
if (!exti@simple && !is(object, superClass))
next
superDef <- getClassDef(superClass, package = packageSlot(exti))
if (is.null(superDef)) {
errors <- c(errors, paste0("superclass \"", superClass,
"\" not defined in the environment of the object's class"))
break
}
validityMethod <- superDef@validity
if (is(validityMethod, "function")) {
errors <- c(errors, anyStrings(validityMethod(as(object,
superClass))))
if (length(errors))
break
}
}
validityMethod <- classDef@validity
if (length(errors) == 0L && is(validityMethod, "function")) {
errors <- c(errors, anyStrings(validityMethod(object)))
}
if (length(errors)) {
if (test)
errors
else {
msg <- gettextf("invalid class %s object", dQuote(Class))
if (length(errors) > 1L)
stop(paste(paste0(msg, ":"), paste(seq_along(errors),
errors, sep = ": "), collapse = "\n"), domain = NA)
else stop(msg, ": ", errors, domain = NA)
}
}
else TRUE
}
integrateIt(newIntegral(1:4, 1:4, Trap))
newIntegral(1:4, 1:4, Trap)
newIntegral(1:4, 1:4, Simpson)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
newIntegral(1:4, 1:4, trapezoid)
setClass(Class = "Integral",
representation = representation(
x = "numeric",
y = "numeric",
rule = "integer")) ## indicates 3 inputs; x and y, which must both be numeric, and rule, which must be a character
newIntegral = function(x, y, rule){ ## construction function takes in 3 arguments; x, y, and rule
object = new("Integral", x = x, y = y, rule = z) ## creates a new object setting the 3 inputsas defined for class Integral
return(object) ## returns the object
}
newIntegral(1:4, 1:4, trapezoid)
newIntegral = function(x, y, rule){ ## construction function takes in 3 arguments; x, y, and rule
object = new("Integral", x = x, y = y, z = rule) ## creates a new object setting the 3 inputsas defined for class Integral
return(object) ## returns the object
}
newIntegral(1:4, 1:4, trapezoid)
newIntegral = function(x, y, rule){ ## construction function takes in 3 arguments; x, y, and rule
object = new("Integral", x = x, y = y, z = rule) ## creates a new object setting the 3 inputsas defined for class Integral
return(object) ## returns the object
}
newIntegral(1:4, 1:4, trapezoid)
newIntegral(1:4, 1:4, "trapezoid")
newIntegral = function(x, y, z){ ## construction function takes in 3 arguments; x, y, and rule
object = new("Integral", x = x, y = y, rule = z) ## creates a new object setting the 3 inputsas defined for class Integral
return(object) ## returns the object
}
newIntegral(1:4, 1:4, "trapezoid")
setClass(Class = "Integral",
representation = representation(
x = "numeric",
y = "numeric",
rule = "character")) ## indicates 3 inputs; x and y, which must both be numeric, and rule, which must be a character
newIntegral = function(x, y, z){ ## construction function takes in 3 arguments; x, y, and rule
object = new("Integral", x = x, y = y, rule = z) ## creates a new object setting the 3 inputsas defined for class Integral
return(object) ## returns the object
}
newIntegral(1:4, 1:4, "trapezoid")
integrateIt(newIntegral(1:4, 1:4, trapezoid))
integrateIt(newIntegral(1:4, 1:4, Trap))
integrateIt(newIntegral(1:4, 1:4, trapezoid))
integrateIt(newIntegral(1:4, 1:4, "trapezoid"))
integrateIt(newIntegral(1:4, 1:4, "Trap"))
integrateIt(newIntegral(1:4, 1:4, "Trap"))
integrateIt(newIntegral(1:4, 1:4, "Trap"))
sub_trap = setdiff(object, object@rule)
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
return(c(sub_trap, Trap(sub_trap), "Trapezoid"))
}
else{
sub_simp = newSimpson(sub_obj)
return(c(sub_simp, Simpson(object), "Simpson"))
}
}
)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
return(list(sub_trap, Trap(sub_trap), "Trapezoid"))
}
else{
sub_simp = newSimpson(sub_obj)
return(list(sub_simp, Simpson(object), "Simpson"))
}
}
)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
return(list(sub_trap, Trap(sub_trap), "Trapezoid"))
}
else{
sub_simp = newSimpson(sub_obj)
return(list(sub_simp, Simpson(object), "Simpson"))
}
}
)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
integrateIt(newIntegral(1:4, 1:4, "Trap"))
function (x, mode = "any")
.Internal(as.vector(x, mode))
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
return(list(sub_trap, Trap(sub_trap), "Trapezoid"))
}
else if(object@rule == "Simpson"){
sub_simp = newSimpson(sub_obj)
return(list(sub_simp, Simpson(object), "Simpson"))
}
}
)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
print(list(sub_trap, Trap(sub_trap), "Trapezoid"))
}
else if(object@rule == "Simpson"){
sub_simp = newSimpson(sub_obj)
print(list(sub_simp, Simpson(object), "Simpson"))
}
}
)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
return(object))
}
else if(object@rule == "Simpson"){
sub_simp = newSimpson(sub_obj)
print(list(sub_simp, Simpson(object), "Simpson"))
}
}
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
return(object)
}
else if(object@rule == "Simpson"){
sub_simp = newSimpson(sub_obj)
print(list(sub_simp, Simpson(object), "Simpson"))
}
}
)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
setMethod("integrateIt", signature("Integral"),
function(object){
sub_obj = setdiff(object, object@rule)
if(object@rule == "Trap"){
sub_trap = newTrapezoid(sub_obj)
return(sub_trap)
}
else if(object@rule == "Simpson"){
sub_simp = newSimpson(sub_obj)
print(list(sub_simp, Simpson(object), "Simpson"))
}
}
)
integrateIt(newIntegral(1:4, 1:4, "Trap"))
integrateIt(newIntegral(1:4, 1:4, "Trap"))
newIntegral(1:4, 1:4, "Trap")
Integral = newIntegral(1:4, 1:4, "Trap")
as.Trapezoid(Integral)
setClass(Class = "Trapezoid", ## creates a new class "Trapezoid"
representation = representation(
x = "numeric",
y = "numeric",
rule = "Trap"
) ## indicates 2 inputs; x and y, which must both be numeric
)
setClass(Class = "Trapezoid", ## creates a new class "Trapezoid"
representation = representation(
x = "numeric",
y = "numeric",
rule = "character"
) ## indicates 2 inputs; x and y, which must both be numeric
)
newSimpson = function(x, y, rule){ ## construction function takes in 2 arguments; x and y
object = new("Simpson", x = x, y = y, rule = "Simpson") ## creates a new object setting the 2 inputs x and y as defined for class Simpson
return(object) ## returns the object
}
newTrapezoid = function(x, y, rule){ ## construction function takes in 2 arguments; x and y
object = new("Trapezoid", x = x, y = y, rule = "Trap") ## creates a new object setting the 2 inputs x and y as defined for class Trapezoid
return(object) ## returns the object
}
checkLength = function(object){ ## creates a function to check if x and y are the same length and returns error message if not
test1 = (length(object@x) == length(object@y))
if (!test1){
return("x and y must be of the same length")}
else{
return(TRUE)}
}
Simpson1 = newSimpson(q,z)
Simpson1 = newSimpson(q,z,Simpson)
Simpson1 = newSimpson(q,z,"Simpson")
Simpson1 = newSimpson(q, z, "Simpson")
Simpson1 = newSimpson(q, z, "Simpson")
Simpson1 = newSimpson(q, z, "Simpson")
newSimpson = function(x, y, rule){ ## construction function takes in 2 arguments; x and y
object = new("Simpson", x = x, y = y, rule = z) ## creates a new object setting the 2 inputs x and y as defined for class Simpson
return(object) ## returns the object
}
newTrapezoid = function(x, y, rule){ ## construction function takes in 2 arguments; x and y
object = new("Trapezoid", x = x, y = y, rule = z) ## creates a new object setting the 2 inputs x and y as defined for class Trapezoid
return(object) ## returns the object
}
Simpson1 = newSimpson(q, z, "Simpson")
Simpson1 = newSimpson(q, z, "Simpson")
Simpson1 = newSimpson(q, z, "Simpson")
newSimpson = function(x, y, rule){ ## construction function takes in 2 arguments; x and y
object = new("Simpson", x = x, y = y, rule = z) ## creates a new object setting the 2 inputs x and y as defined for class Simpson
return(object) ## returns the object
}
newTrapezoid = function(x, y, rule){ ## construction function takes in 2 arguments; x and y
object = new("Trapezoid", x = x, y = y, rule = z) ## creates a new object setting the 2 inputs x and y as defined for class Trapezoid
return(object) ## returns the object
}
Integral = newIntegral(1:4, 1:4, "Trap")
Simpson1 = newSimpson(q, z, "Simpson")
Simpson2 = newSimpson(q,w)
Simpson2 = newSimpson(q, w, "Simpson")
Trap1 = newTrapezoid(q,z) ## test
